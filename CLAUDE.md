# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

ClaudeBar is a macOS menu bar application that monitors AI coding assistant usage quotas (Claude, Codex, Gemini, GitHub Copilot). It probes CLI tools to fetch quota information and displays it in a menu bar interface with system notifications for status changes.

## Build & Test Commands

### Using Swift Package Manager (CLI)

```bash
# Build the project
swift build

# Run all tests
swift test

# Run a specific test file
swift test --filter DomainTests

# Run a specific test
swift test --filter "QuotaMonitorTests/monitor fetches usage from a single provider"

# Run the app (requires macOS 15+)
swift run ClaudeBar
```

### Using Tuist (Xcode with SwiftUI Previews)

The project uses [Tuist](https://tuist.io) to generate Xcode projects with proper build settings for SwiftUI previews.

```bash
# Generate Xcode project (required before opening in Xcode)
tuist generate

# Open in Xcode (after generating)
open ClaudeBar.xcworkspace

# Regenerate after changing Project.swift
tuist generate
```

**Key files:**
- `Project.swift` - Tuist project definition (targets, dependencies, build settings)
- `Tuist.swift` - Tuist configuration
- `Package.swift` - Still used for SPM dependencies and CLI builds

**Note:** `*.xcodeproj` and `*.xcworkspace` are git-ignored since they're generated by Tuist.

## Architecture

The project follows a layered architecture with protocol-based dependency injection:

### Layers

- **Domain** (`Sources/Domain/`): Pure business logic with no external dependencies
  - Provider (`Provider/`): `AIProvider` protocol, `UsageProbe` protocol, and rich models (`UsageQuota`, `UsageSnapshot`, `QuotaStatus`)
  - Monitor (`Monitor/`): `QuotaMonitor` actor and `StatusChangeObserver` protocol

- **Infrastructure** (`Sources/Infrastructure/`): Technical implementations
  - CLI (`CLI/`): Probes and protocols for CLI interaction
    - `ClaudeUsageProbe` - probes Claude CLI, uses `CLIExecutor` for testability
    - `CodexUsageProbe` - delegates to `CodexRPCClient` (single dependency)
    - `CodexRPCClient` protocol - "Is it available?" and "Get my stats"
    - `DefaultCodexRPCClient` - RPC via `RPCTransport`, falls back to TTY via `CLIExecutor`
    - `CLIExecutor` protocol - abstracts CLI interaction (locate binary, execute commands)
    - `RPCTransport` protocol - abstracts JSON-RPC communication
    - `GeminiUsageProbe` - coordinates `GeminiAPIProbe` with network client
    - `GeminiProjectRepository` - discovers Gemini projects for quota lookup
    - `CopilotUsageProbe` - probes GitHub Copilot usage via credentials and API
  - Adapters (`Adapters/`): Pure adapters for 3rd party interaction (excluded from coverage)
    - `PTYCommandRunner` - runs CLI commands with PTY for interactive prompts
    - `ProcessRPCTransport` - JSON-RPC over Process stdin/stdout pipes
    - `DefaultCLIExecutor` - real CLI execution using PTYCommandRunner
  - Network (`Network/`): `NetworkClient` protocol for HTTP abstraction
  - Notifications (`Notifications/`): `NotificationQuotaObserver` - macOS notification center

- **App** (`Sources/App/`): SwiftUI menu bar application
  - Views directly consume domain models (no ViewModel layer)
  - `AppState` is an `@Observable` class shared across views
  - `StatusBarIcon` - menu bar icon with status indicator

### Key Patterns

- **Protocol-Based DI**: Domain defines protocols (`UsageProbe`, `StatusChangeObserver`), infrastructure provides implementations
- **Actor-based concurrency**: `QuotaMonitor` is an actor for thread-safe state management
- **Mockable protocol mocks**: Uses `@Mockable` macro from Mockable package for test doubles
- **Swift Testing framework**: Tests use `@Test` and `@Suite` attributes, not XCTest
- **Adapters folder**: Pure 3rd-party wrappers excluded from code coverage

### Testability Design

The codebase separates testable logic from external system interaction:

- **Protocols with `@Mockable`**: `CLIExecutor`, `RPCTransport`, `CodexRPCClient`, `NetworkClient` - all mockable for unit tests
- **Adapters folder**: Pure adapters (`PTYCommandRunner`, `ProcessRPCTransport`) are excluded from code coverage since they only wrap system APIs
- **Parsing logic**: Kept as static/internal methods for direct testing without mocks

### Adding a New AI Provider

1. Create a new provider class implementing `AIProvider` in `Sources/Domain/Provider/`
2. Create probe in `Sources/Infrastructure/CLI/` implementing `UsageProbe`
3. Register provider in `ClaudeBarApp.init()`
4. Add parsing tests in `Tests/InfrastructureTests/CLI/`

## Assets

The project uses a standard Xcode asset catalog for images:

```
Sources/App/Resources/
├── Assets.xcassets/           # Used at runtime
│   ├── AppIcon.appiconset/    # App icon (all sizes)
│   ├── AppLogo.imageset/      # App logo
│   ├── ClaudeIcon.imageset/   # Provider icons (PNG @1x, @2x, @3x)
│   ├── CodexIcon.imageset/
│   ├── CopilotIcon.imageset/
│   └── GeminiIcon.imageset/
├── ClaudeIcon.svg             # Source SVG files (kept for reference)
├── CodexIcon.svg
├── CopilotIcon.png
└── GeminiIcon.svg
```

- **Runtime**: PNGs from `Assets.xcassets` loaded via `NSImage(named:)`
- **Source**: SVGs kept as original files for future regeneration

## Versioning & Release

### How Version Updates Work (with Tuist)

The release workflow updates version before Tuist generates the project:

```
1. GitHub Action triggered (tag v1.0.0 or manual input)
2. Update Info.plist ← PlistBuddy sets CFBundleShortVersionString
3. tuist generate   ← Reads updated Info.plist
4. xcodebuild       ← Builds app with correct version
5. Sparkle appcast  ← Generated with version for auto-updates
```

**Key files:**
- `Sources/App/Info.plist` - Source of truth for version (`CFBundleShortVersionString`, `CFBundleVersion`)
- `Project.swift` - References Info.plist: `infoPlist: .file(path: "Sources/App/Info.plist")`

### Manual Version Update (Local Development)

```bash
# Update version in Info.plist
/usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString 1.0.0" Sources/App/Info.plist
/usr/libexec/PlistBuddy -c "Set :CFBundleVersion 1" Sources/App/Info.plist

# Regenerate Xcode project
tuist generate
```

### Creating a Release

```bash
# Tag and push to trigger release workflow
git tag v1.0.0
git push origin v1.0.0
```

Or use the manual workflow dispatch in GitHub Actions with version input.

## Logging

The app uses Apple's **OSLog framework** via a centralized `Logger` extension in `Sources/App/AppLogger.swift`.

### Logger Categories

```swift
Logger.monitor        // QuotaMonitor operations
Logger.providers      // AI provider lifecycle  
Logger.probes         // CLI probe execution
Logger.network        // HTTP requests/responses
Logger.credentials    // Token management (use .private!)
Logger.ui             // SwiftUI view lifecycle
Logger.notifications  // System notifications
Logger.updates        // Sparkle updates
```

### Privacy Rules

- **Always use `.private`** for: tokens, API keys, CLI output, usernames
- **Use `.private(mask: .hash)`** for: correlation IDs you need to track
- **Safe as `.public`**: provider names, status enums, counts, URLs

### Log Levels

OSLog levels are used at the **call site** - you choose the level when logging:

| Level | Method | Persistence | Use Case |
|-------|--------|-------------|----------|
| `trace` | `.trace()` | Memory only | Extremely verbose debugging |
| `debug` | `.debug()` | Memory only | Development diagnostics |
| `info` | `.info()` | With `log collect` | Informational events |
| `notice` | `.notice()` | Always persisted | Significant events |
| `warning` | `.warning()` | Always persisted | Potential issues |
| `error` | `.error()` | Always persisted | Recoverable errors |
| `fault` | `.fault()` | Always persisted | Critical failures |

**Key insight**: OSLog filtering happens at the *consumer* level (Console.app, `log` command), not at the app level. The app emits all logs - the OS filters what gets shown/persisted based on level.

### Viewing Logs

```bash
# Console.app filter
subsystem:com.tddworks.ClaudeBar

# Terminal - show all levels (including debug)
log show --predicate 'subsystem == "com.tddworks.ClaudeBar"' --info --debug --last 1h

# Terminal - errors only
log show --predicate 'subsystem == "com.tddworks.ClaudeBar" AND messageType == error' --last 1h

# Live stream (for debugging)
log stream --predicate 'subsystem == "com.tddworks.ClaudeBar"' --info --debug
```

### Debugging Probe Issues

When a probe fails (e.g., `claude /usage`), all errors are logged with context:

```bash
# See probe-specific logs
log show --predicate 'subsystem == "com.tddworks.ClaudeBar" AND category == "probes"' --info --debug --last 1h
```

Common error patterns logged:
- `"Claude probe failed: token has expired"` → Re-login required
- `"Claude probe blocked: folder trust required"` → Trust the folder in Claude CLI
- `"Codex probe failed: data not available yet"` → Wait for Codex to sync
- `"Gemini probe failed: no access token"` → Re-authenticate with Gemini CLI

## Dependencies

- **Sparkle**: Auto-update framework for macOS
- **Mockable**: Protocol mocking for tests via Swift macros
- **Tuist**: Xcode project generation for SwiftUI previews (`ENABLE_DEBUG_DYLIB`)
